<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Panélisation | William-Dew</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%2310b981' width='100' height='100' rx='15'/%3E%3Crect fill='%23059669' x='10' y='10' width='35' height='35' rx='3'/%3E%3Crect fill='%23059669' x='55' y='10' width='35' height='35' rx='3'/%3E%3Crect fill='%23059669' x='10' y='55' width='35' height='35' rx='3'/%3E%3Crect fill='%23059669' x='55' y='55' width='35' height='35' rx='3'/%3E%3Ccircle fill='%23fbbf24' cx='27.5' cy='27.5' r='4'/%3E%3Ccircle fill='%23fbbf24' cx='72.5' cy='27.5' r='4'/%3E%3Ccircle fill='%23fbbf24' cx='27.5' cy='72.5' r='4'/%3E%3Ccircle fill='%23fbbf24' cx='72.5' cy='72.5' r='4'/%3E%3C/svg%3E">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <style>
        .modal-backdrop {
            backdrop-filter: blur(12px);
        }
        .tooltip {
            position: relative;
        }
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s;
            position: absolute;
            z-index: 100;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1e293b;
            color: white;
            padding: 8px 14px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            font-weight: 500;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -6px;
            border-width: 6px;
            border-style: solid;
            border-color: #1e293b transparent transparent transparent;
        }
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .slide-in {
            animation: slideIn 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .section-card {
            transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .section-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 20px 40px rgba(0,0,0,0.12);
        }
        
        /* Inputs professionnels */
        input[type="number"], input[type="text"] {
            transition: all 0.2s ease;
        }
        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        /* Scrollbar personnalisée */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 5px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;

        const Icon = ({ name, className = "w-5 h-5" }) => {
            const iconRef = React.useRef(null);
            
            React.useEffect(() => {
                if (iconRef.current && window.lucide) {
                    const iconElement = window.lucide.createElement(window.lucide[name]);
                    iconRef.current.innerHTML = '';
                    iconRef.current.appendChild(iconElement);
                }
            }, [name]);
            
            return <i ref={iconRef} className={className}></i>;
        };

        const Tooltip = ({ text, children }) => (
            <div className="tooltip inline-block">
                {children}
                <span className="tooltip-text">{text}</span>
            </div>
        );

        const STANDARD_FORMATS = [
            { name: 'DF 600x500mm', width: 600, height: 500, category: 'DOUBLE FACE' },
            { name: 'DF 610x450mm', width: 610, height: 450, category: 'DOUBLE FACE' },
            { name: 'DF 460x300mm', width: 460, height: 300, category: 'DOUBLE FACE' },
            { name: 'MC 580x510mm', width: 580, height: 510, category: 'MULTICOUCHES' },
            { name: 'MC 570x480mm', width: 570, height: 480, category: 'MULTICOUCHES' },
        ];

        const PRESET_SPACINGS = [
            { value: 0, label: 'Panolplie V-cut' },
            { value: 2, label: '2mm' },
            { value: 5, label: '5mm' },
            { value: 10, label: '10mm' },
            { value: 12.5, label: '12.5mm' },
        ];

        const DEFAULT_VALUES = {
            pcbWidth: 80,
            pcbHeight: 70,
            frameMargin: 15,
            spacing: 5,
            panoplieFrameMargin: 8,
            panoplieSpacing: 2,
            panoplieEntraxe: 5
        };

        const calculateConfig = (
            primaryOrientation,
            primaryCols,
            primaryRows,
            pcbW,
            pcbH,
            spacing,
            availableWidth,
            availableHeight,
            enableMixedMode
        ) => {
            const isPrimary0 = primaryOrientation === 0;
            const primaryW = isPrimary0 ? pcbW : pcbH;
            const primaryH = isPrimary0 ? pcbH : pcbW;
            const secondaryW = isPrimary0 ? pcbH : pcbW;
            const secondaryH = isPrimary0 ? pcbW : pcbH;

            const primaryCount = primaryCols * primaryRows;
            const primaryUsedW = primaryCols * primaryW + (primaryCols - 1) * spacing;
            const primaryUsedH = primaryRows * primaryH + (primaryRows - 1) * spacing;

            const rightSpace = availableWidth - primaryUsedW;
            const bottomSpace = availableHeight - primaryUsedH;

            let secondaryPcbs = [];
            let secondaryCount = 0;

            if (enableMixedMode) {
                if (rightSpace >= secondaryW + spacing) {
                    const rightCols = Math.floor((rightSpace - spacing) / (secondaryW + spacing));
                    const rightRows = Math.floor((primaryUsedH + spacing) / (secondaryH + spacing));
                    if (rightCols > 0 && rightRows > 0) {
                        for (let row = 0; row < rightRows; row++) {
                            for (let col = 0; col < rightCols; col++) {
                                secondaryPcbs.push({
                                    x: primaryUsedW + spacing + col * (secondaryW + spacing),
                                    y: row * (secondaryH + spacing),
                                    w: secondaryW,
                                    h: secondaryH,
                                    orientation: isPrimary0 ? 90 : 0
                                });
                                secondaryCount++;
                            }
                        }
                    }
                }

                if (bottomSpace >= secondaryH + spacing) {
                    const bottomCols = Math.floor((availableWidth + spacing) / (secondaryW + spacing));
                    const bottomRows = Math.floor((bottomSpace - spacing) / (secondaryH + spacing));
                    if (bottomCols > 0 && bottomRows > 0) {
                        for (let row = 0; row < bottomRows; row++) {
                            for (let col = 0; col < bottomCols; col++) {
                                secondaryPcbs.push({
                                    x: col * (secondaryW + spacing),
                                    y: primaryUsedH + spacing + row * (secondaryH + spacing),
                                    w: secondaryW,
                                    h: secondaryH,
                                    orientation: isPrimary0 ? 90 : 0
                                });
                                secondaryCount++;
                            }
                        }
                    }
                }
            }

            const totalCount = primaryCount + secondaryCount;
            const pcbArea = pcbW * pcbH;
            const totalArea = totalCount * pcbArea;
            const utilization = (totalArea / (availableWidth * availableHeight)) * 100;

            return {
                primaryOrientation,
                primaryCols,
                primaryRows,
                primaryCount,
                secondaryCount,
                totalCount,
                utilization,
                primaryW,
                primaryH,
                secondaryPcbs,
                usedWidth: primaryUsedW,
                usedHeight: primaryUsedH,
                description: enableMixedMode 
                    ? `${primaryOrientation}° (${primaryCols}×${primaryRows}) + ${isPrimary0 ? '90°' : '0°'} (${secondaryCount})`
                    : `${primaryOrientation}° (${primaryCols}×${primaryRows})`
            };
        };

        const calculateSinglePanoplieConfig = (
            panopliesPerRow,
            panopliesPerCol,
            orientation,
            panoplieCols,
            panoplieRows,
            pcbW,
            pcbH,
            spacing,
            panoplieFrameMargin,
            panoplieEntraxe,
            availableWidth,
            availableHeight,
            enableMixedMode,
            panoplieWidth,
            panoplieHeight,
            pcbsPerPanoplie
        ) => {
            const isOrientation0 = orientation === 0;
            const invertedOrientation = isOrientation0 ? 90 : 0;
            const pcbWidthUsed = isOrientation0 ? pcbW : pcbH;
            const pcbHeightUsed = isOrientation0 ? pcbH : pcbW;

            const totalPanopliesPrimary = panopliesPerRow * panopliesPerCol;
            const primaryUsedWidth = panopliesPerRow * panoplieWidth + (panopliesPerRow - 1) * panoplieEntraxe;
            const primaryUsedHeight = panopliesPerCol * panoplieHeight + (panopliesPerCol - 1) * panoplieEntraxe;

            const allPcbs = [];
            const panoplieFramesData = new Map();
            let panoplieIndex = 0;
            
            for (let panoplieRow = 0; panoplieRow < panopliesPerCol; panoplieRow++) {
                for (let panoplieCol = 0; panoplieCol < panopliesPerRow; panoplieCol++) {
                    const panoplieOffsetX = panoplieCol * (panoplieWidth + panoplieEntraxe);
                    const panoplieOffsetY = panoplieRow * (panoplieHeight + panoplieEntraxe);
                    
                    panoplieFramesData.set(panoplieIndex, {
                        x: panoplieOffsetX,
                        y: panoplieOffsetY,
                        w: panoplieWidth,
                        h: panoplieHeight,
                        orientation: orientation
                    });

                    for (let row = 0; row < panoplieRows; row++) {
                        for (let col = 0; col < panoplieCols; col++) {
                            allPcbs.push({
                                x: panoplieOffsetX + panoplieFrameMargin + col * (pcbWidthUsed + spacing),
                                y: panoplieOffsetY + panoplieFrameMargin + row * (pcbHeightUsed + spacing),
                                w: pcbWidthUsed,
                                h: pcbHeightUsed,
                                panoplieIndex,
                                panoplieOffsetX,
                                panoplieOffsetY,
                                orientation: orientation
                            });
                        }
                    }
                    panoplieIndex++;
                }
            }

            let secondaryPanoplies = 0;
            
            if (enableMixedMode) {
                // CORRECTION : Pour pivoter une panoplie, on échange sa largeur/hauteur ET les colonnes/rangées
                const panoplieWidthRotated = panoplieHeight;
                const panoplieHeightRotated = panoplieWidth;
                
                // Les PCB dans la panoplie pivotée sont aussi pivotés
                const pcbWidthUsedRotated = isOrientation0 ? pcbH : pcbW;
                const pcbHeightUsedRotated = isOrientation0 ? pcbW : pcbH;
                
                // IMPORTANT: Quand on pivote, les colonnes et rangées s'inversent !
                const panoplieColsRotated = panoplieRows;
                const panoplieRowsRotated = panoplieCols;

                const rightSpace = availableWidth - primaryUsedWidth;
                if (rightSpace >= panoplieWidthRotated + panoplieEntraxe) {
                    const rightCols = Math.floor((rightSpace - panoplieEntraxe) / (panoplieWidthRotated + panoplieEntraxe));
                    const rightRows = Math.floor((primaryUsedHeight + panoplieEntraxe) / (panoplieHeightRotated + panoplieEntraxe));
                    
                    for (let panoplieRow = 0; panoplieRow < rightRows; panoplieRow++) {
                        for (let panoplieCol = 0; panoplieCol < rightCols; panoplieCol++) {
                            const panoplieOffsetX = primaryUsedWidth + panoplieEntraxe + panoplieCol * (panoplieWidthRotated + panoplieEntraxe);
                            const panoplieOffsetY = panoplieRow * (panoplieHeightRotated + panoplieEntraxe);
                            
                            panoplieFramesData.set(panoplieIndex, {
                                x: panoplieOffsetX,
                                y: panoplieOffsetY,
                                w: panoplieWidthRotated,
                                h: panoplieHeightRotated,
                                orientation: invertedOrientation
                            });

                            for (let row = 0; row < panoplieRowsRotated; row++) {
                                for (let col = 0; col < panoplieColsRotated; col++) {
                                    allPcbs.push({
                                        x: panoplieOffsetX + panoplieFrameMargin + col * (pcbWidthUsedRotated + spacing),
                                        y: panoplieOffsetY + panoplieFrameMargin + row * (pcbHeightUsedRotated + spacing),
                                        w: pcbWidthUsedRotated,
                                        h: pcbHeightUsedRotated,
                                        panoplieIndex,
                                        panoplieOffsetX,
                                        panoplieOffsetY,
                                        orientation: invertedOrientation
                                    });
                                }
                            }
                            secondaryPanoplies++;
                            panoplieIndex++;
                        }
                    }
                }

                const bottomSpace = availableHeight - primaryUsedHeight;
                if (bottomSpace >= panoplieHeightRotated + panoplieEntraxe) {
                    const bottomCols = Math.floor((availableWidth + panoplieEntraxe) / (panoplieWidthRotated + panoplieEntraxe));
                    const bottomRows = Math.floor((bottomSpace - panoplieEntraxe) / (panoplieHeightRotated + panoplieEntraxe));
                    
                    for (let panoplieRow = 0; panoplieRow < bottomRows; panoplieRow++) {
                        for (let panoplieCol = 0; panoplieCol < bottomCols; panoplieCol++) {
                            const panoplieOffsetX = panoplieCol * (panoplieWidthRotated + panoplieEntraxe);
                            const panoplieOffsetY = primaryUsedHeight + panoplieEntraxe + panoplieRow * (panoplieHeightRotated + panoplieEntraxe);
                            
                            panoplieFramesData.set(panoplieIndex, {
                                x: panoplieOffsetX,
                                y: panoplieOffsetY,
                                w: panoplieWidthRotated,
                                h: panoplieHeightRotated,
                                orientation: invertedOrientation
                            });

                            for (let row = 0; row < panoplieRowsRotated; row++) {
                                for (let col = 0; col < panoplieColsRotated; col++) {
                                    allPcbs.push({
                                        x: panoplieOffsetX + panoplieFrameMargin + col * (pcbWidthUsedRotated + spacing),
                                        y: panoplieOffsetY + panoplieFrameMargin + row * (pcbHeightUsedRotated + spacing),
                                        w: pcbWidthUsedRotated,
                                        h: pcbHeightUsedRotated,
                                        panoplieIndex,
                                        panoplieOffsetX,
                                        panoplieOffsetY,
                                        orientation: invertedOrientation
                                    });
                                }
                            }
                            secondaryPanoplies++;
                            panoplieIndex++;
                        }
                    }
                }
            }

            const totalPanoplies = totalPanopliesPrimary + secondaryPanoplies;
            const totalPcbs = totalPanoplies * pcbsPerPanoplie;
            const pcbArea = pcbW * pcbH;
            const totalArea = totalPcbs * pcbArea;
            const utilization = (totalArea / (availableWidth * availableHeight)) * 100;

            return {
                primaryOrientation: orientation,
                primaryCols: panopliesPerRow * panoplieCols,
                primaryRows: panopliesPerCol * panoplieRows,
                primaryCount: totalPanopliesPrimary * pcbsPerPanoplie,
                secondaryCount: secondaryPanoplies * pcbsPerPanoplie,
                totalCount: totalPcbs,
                utilization,
                primaryW: pcbWidthUsed,
                primaryH: pcbHeightUsed,
                secondaryPcbs: [],
                isPanoplie: true,
                panoplieWidth,
                panoplieHeight,
                panopliesPerRow,
                panopliesPerCol,
                totalPanoplies,
                totalPanopliesPrimary,
                secondaryPanoplies,
                pcbsPerPanoplie,
                panoplieEntraxe,
                panoplieFrameMargin,
                allPcbs,
                panoplieFramesData,
                description: enableMixedMode && secondaryPanoplies > 0
                    ? `${totalPanopliesPrimary} panoplies ${orientation}° + ${secondaryPanoplies} panoplies ${invertedOrientation}° = ${totalPcbs} PCB`
                    : `${totalPanoplies} panoplies de ${panoplieCols}×${panoplieRows} = ${totalPcbs} PCB`
            };
        };

        const calculatePanoplieOptimization = (
            panoplieCols,
            panoplieRows,
            orientation,
            pcbW,
            pcbH,
            spacing,
            panoplieFrameMargin,
            panoplieEntraxe,
            availableWidth,
            availableHeight,
            enableMixedMode
        ) => {
            const isOrientation0 = orientation === 0;
            const pcbWidthUsed = isOrientation0 ? pcbW : pcbH;
            const pcbHeightUsed = isOrientation0 ? pcbH : pcbW;

            const pcbAreaWidth = panoplieCols * pcbWidthUsed + (panoplieCols - 1) * spacing;
            const pcbAreaHeight = panoplieRows * pcbHeightUsed + (panoplieRows - 1) * spacing;
            const panoplieWidth = pcbAreaWidth + (2 * panoplieFrameMargin);
            const panoplieHeight = pcbAreaHeight + (2 * panoplieFrameMargin);

            const panopliesPerRowFull = Math.floor((availableWidth + panoplieEntraxe) / (panoplieWidth + panoplieEntraxe));
            const panopliesPerColFull = Math.floor((availableHeight + panoplieEntraxe) / (panoplieHeight + panoplieEntraxe));

            const pcbsPerPanoplie = panoplieCols * panoplieRows;

            const configurations = [];

            configurations.push(
                calculateSinglePanoplieConfig(
                    panopliesPerRowFull, panopliesPerColFull,
                    orientation, panoplieCols, panoplieRows,
                    pcbW, pcbH, spacing, panoplieFrameMargin, panoplieEntraxe,
                    availableWidth, availableHeight, enableMixedMode,
                    panoplieWidth, panoplieHeight, pcbsPerPanoplie
                )
            );

            if (enableMixedMode) {
                if (panopliesPerRowFull > 1) {
                    configurations.push(
                        calculateSinglePanoplieConfig(
                            panopliesPerRowFull - 1, panopliesPerColFull,
                            orientation, panoplieCols, panoplieRows,
                            pcbW, pcbH, spacing, panoplieFrameMargin, panoplieEntraxe,
                            availableWidth, availableHeight, true,
                            panoplieWidth, panoplieHeight, pcbsPerPanoplie
                        )
                    );
                }

                if (panopliesPerColFull > 1) {
                    configurations.push(
                        calculateSinglePanoplieConfig(
                            panopliesPerRowFull, panopliesPerColFull - 1,
                            orientation, panoplieCols, panoplieRows,
                            pcbW, pcbH, spacing, panoplieFrameMargin, panoplieEntraxe,
                            availableWidth, availableHeight, true,
                            panoplieWidth, panoplieHeight, pcbsPerPanoplie
                        )
                    );
                }

                if (panopliesPerRowFull > 1 && panopliesPerColFull > 1) {
                    configurations.push(
                        calculateSinglePanoplieConfig(
                            panopliesPerRowFull - 1, panopliesPerColFull - 1,
                            orientation, panoplieCols, panoplieRows,
                            pcbW, pcbH, spacing, panoplieFrameMargin, panoplieEntraxe,
                            availableWidth, availableHeight, true,
                            panoplieWidth, panoplieHeight, pcbsPerPanoplie
                        )
                    );
                }
            }

            return configurations.reduce((best, config) => 
                config.totalCount > best.totalCount ? config : best
            );
        };

        const calculateAllConfigurations = (
            panelFormat,
            pcbWidth,
            pcbHeight,
            frameMargin,
            spacing,
            enableMixedMode
        ) => {
            const pcbW = parseFloat(pcbWidth) || DEFAULT_VALUES.pcbWidth;
            const pcbH = parseFloat(pcbHeight) || DEFAULT_VALUES.pcbHeight;
            const parsedMargin = parseFloat(frameMargin);
                const margin = isNaN(parsedMargin) ? DEFAULT_VALUES.frameMargin : parsedMargin;
            const parsedSpace = parseFloat(spacing);
                const space = isNaN(parsedSpace) ? DEFAULT_VALUES.spacing : parsedSpace;
            
            const availableWidth = panelFormat.width - (2 * margin);
            const availableHeight = panelFormat.height - (2 * margin);

            const configurations = [];

            const cols0Full = Math.floor((availableWidth + space) / (pcbW + space));
            const rows0Full = Math.floor((availableHeight + space) / (pcbH + space));
            if (cols0Full > 0 && rows0Full > 0) {
                configurations.push(
                    calculateConfig(0, cols0Full, rows0Full, pcbW, pcbH, space, availableWidth, availableHeight, enableMixedMode)
                );
            }

            const cols90Full = Math.floor((availableWidth + space) / (pcbH + space));
            const rows90Full = Math.floor((availableHeight + space) / (pcbW + space));
            if (cols90Full > 0 && rows90Full > 0) {
                configurations.push(
                    calculateConfig(90, cols90Full, rows90Full, pcbW, pcbH, space, availableWidth, availableHeight, enableMixedMode)
                );
            }

            if (enableMixedMode) {
                if (rows0Full > 1) {
                    configurations.push(
                        calculateConfig(0, cols0Full, rows0Full - 1, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (cols0Full > 1) {
                    configurations.push(
                        calculateConfig(0, cols0Full - 1, rows0Full, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (rows90Full > 1) {
                    configurations.push(
                        calculateConfig(90, cols90Full, rows90Full - 1, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (cols90Full > 1) {
                    configurations.push(
                        calculateConfig(90, cols90Full - 1, rows90Full, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (rows0Full > 2) {
                    configurations.push(
                        calculateConfig(0, cols0Full, rows0Full - 2, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (cols0Full > 2) {
                    configurations.push(
                        calculateConfig(0, cols0Full - 2, rows0Full, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (rows90Full > 2) {
                    configurations.push(
                        calculateConfig(90, cols90Full, rows90Full - 2, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }

                if (cols90Full > 2) {
                    configurations.push(
                        calculateConfig(90, cols90Full - 2, rows90Full, pcbW, pcbH, space, availableWidth, availableHeight, true)
                    );
                }
            }

            const best = configurations.reduce((max, config) => 
                config.totalCount > max.totalCount ? config : max
            , configurations[0] || { totalCount: 0 });

            return {
                best,
                allConfigs: configurations.sort((a, b) => b.totalCount - a.totalCount).slice(0, 6),
                availableWidth,
                availableHeight
            };
        };

        // Composant pour mire CMS (cible avec croix)
        const CMSTarget = ({ x, y, scale, symbol, isRight = false }) => {
            const size = 4 * scale;
            const circleRadius = size * 1.3;
            const crossSize = size * 2;
            const symbolOffset = isRight ? -(circleRadius + 15) : (circleRadius + 15);
            
            return (
                <g>
                    {/* Ombre subtile */}
                    <circle cx={x + 1} cy={y + 1} r={circleRadius} fill="#000000" opacity="0.1" />
                    
                    {/* Cercles de la cible */}
                    <circle cx={x} cy={y} r={circleRadius} fill="none" stroke="#dc2626" strokeWidth="2.5" />
                    <circle cx={x} cy={y} r={circleRadius * 0.65} fill="none" stroke="#dc2626" strokeWidth="2" />
                    <circle cx={x} cy={y} r={circleRadius * 0.35} fill="none" stroke="#dc2626" strokeWidth="1.5" />
                    <circle cx={x} cy={y} r={circleRadius * 0.15} fill="#dc2626" />
                    
                    {/* Croix de visée */}
                    <line x1={x - crossSize} y1={y} x2={x + crossSize} y2={y} stroke="#dc2626" strokeWidth="2.5" strokeLinecap="round" />
                    <line x1={x} y1={y - crossSize} x2={x} y2={y + crossSize} stroke="#dc2626" strokeWidth="2.5" strokeLinecap="round" />
                    
                    {/* Badge avec symbole */}
                    <circle cx={x + symbolOffset} cy={y} r="10" fill="white" stroke="#dc2626" strokeWidth="2" filter="url(#shadow)" />
                    <text 
                        x={x + symbolOffset} 
                        y={y} 
                        textAnchor="middle" 
                        dominantBaseline="middle"
                        fill="#dc2626" 
                        fontSize="12" 
                        fontWeight="bold"
                    >
                        {symbol}
                    </text>
                </g>
            );
        };

        // Composant pour trou de localisation
        const LocatingHole = ({ x, y, scale, symbol, isRight = false }) => {
            const diameter = 3.05;
            const radius = (diameter / 2) * scale;
            const symbolOffset = isRight ? -(radius + 12) : (radius + 12);
            
            return (
                <g>
                    {/* Ombre */}
                    <circle cx={x + 1} cy={y + 1} r={radius + 2} fill="#000000" opacity="0.1" />
                    
                    {/* Trou principal */}
                    <circle cx={x} cy={y} r={radius + 2} fill="none" stroke="#2563eb" strokeWidth="2.5" />
                    <circle cx={x} cy={y} r={radius} fill="white" stroke="#2563eb" strokeWidth="2" />
                    <circle cx={x} cy={y} r={radius * 0.4} fill="none" stroke="#2563eb" strokeWidth="1.5" strokeDasharray="2,2" />
                    
                    {/* Croix de centrage */}
                    <line x1={x - radius * 2} y1={y} x2={x + radius * 2} y2={y} stroke="#2563eb" strokeWidth="1.5" strokeLinecap="round" />
                    <line x1={x} y1={y - radius * 2} x2={x} y2={y + radius * 2} stroke="#2563eb" strokeWidth="1.5" strokeLinecap="round" />
                    
                    {/* Badge avec symbole */}
                    <rect 
                        x={x + symbolOffset - 9} 
                        y={y - 9} 
                        width="18" 
                        height="18" 
                        fill="white" 
                        stroke="#2563eb" 
                        strokeWidth="2" 
                        rx="3"
                        filter="url(#shadow)"
                    />
                    <text 
                        x={x + symbolOffset} 
                        y={y} 
                        textAnchor="middle" 
                        dominantBaseline="middle"
                        fill="#2563eb" 
                        fontSize="12" 
                        fontWeight="bold"
                    >
                        {symbol}
                    </text>
                </g>
            );
        };

        // Composant pour ligne V-CUT avec style en V
        const VCutLine = ({ x1, y1, x2, y2, isHorizontal }) => {
            const vSize = 5;
            const vSpacing = 20;
            
            // Créer des encoches en V le long de la ligne
            const vNotches = [];
            if (isHorizontal) {
                const lineLength = x2 - x1;
                const numNotches = Math.floor(lineLength / vSpacing);
                for (let i = 0; i <= numNotches; i++) {
                    const x = x1 + (i * lineLength / numNotches);
                    vNotches.push(
                        <path
                            key={`v-${i}`}
                            d={`M ${x - vSize} ${y1 - vSize} L ${x} ${y1} L ${x + vSize} ${y1 - vSize}`}
                            fill="none"
                            stroke="#f59e0b"
                            strokeWidth="2.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                        />
                    );
                }
            } else {
                const lineLength = y2 - y1;
                const numNotches = Math.floor(lineLength / vSpacing);
                for (let i = 0; i <= numNotches; i++) {
                    const y = y1 + (i * lineLength / numNotches);
                    vNotches.push(
                        <path
                            key={`v-${i}`}
                            d={`M ${x1 - vSize} ${y - vSize} L ${x1} ${y} L ${x1 - vSize} ${y + vSize}`}
                            fill="none"
                            stroke="#f59e0b"
                            strokeWidth="2.5"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                        />
                    );
                }
            }
            
            return (
                <g>
                    {/* Ligne de base */}
                    <line 
                        x1={x1} 
                        y1={y1} 
                        x2={x2} 
                        y2={y2} 
                        stroke="#f59e0b" 
                        strokeWidth="2" 
                        strokeDasharray="10,5"
                        opacity="0.8"
                    />
                    
                    {/* Encoches en V */}
                    {vNotches}
                </g>
            );
        };

        const PanoplieVisualization = ({ panoplieCols, panoplieRows, pcbWidth, pcbHeight, spacing, panoplieFrameMargin, orientation, svgRef, containerRef }) => {
            const cols = parseInt(panoplieCols) || 2;
            const rows = parseInt(panoplieRows) || 3;
            const pcbW = parseFloat(pcbWidth) || 80;
            const pcbH = parseFloat(pcbHeight) || 70;
            const parsedSpace = parseFloat(spacing);
            const space = isNaN(parsedSpace) ? 2 : parsedSpace;
            const parsedFrame = parseFloat(panoplieFrameMargin);
            const frame = isNaN(parsedFrame) ? 8 : parsedFrame;
            
            const isOrientation0 = orientation === 0;
            const pcbWidthUsed = isOrientation0 ? pcbW : pcbH;
            const pcbHeightUsed = isOrientation0 ? pcbH : pcbW;
            
            const pcbAreaWidth = cols * pcbWidthUsed + (cols - 1) * space;
            const pcbAreaHeight = rows * pcbHeightUsed + (rows - 1) * space;
            const panoplieWidth = pcbAreaWidth + (2 * frame);
            const panoplieHeight = pcbAreaHeight + (2 * frame);
            
            const scale = Math.min(1200 / panoplieWidth, 900 / panoplieHeight, 2.5);
            const scaledW = panoplieWidth * scale;
            const scaledH = panoplieHeight * scale;
            const scaledFrame = frame * scale;
            const scaledSpace = space * scale;
            
            // Marges différenciées pour bien voir toutes les cotations
            const marginLeft = 80;
            const marginTop = 80;
            const marginRight = 100;
            const marginBottom = 120;
            const svgWidth = scaledW + marginLeft + marginRight;
            const svgHeight = scaledH + marginTop + marginBottom;
            
            // Utiliser marginLeft et marginTop pour positionner les éléments
            const margin = marginLeft;
            
            const pcbs = [];
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = margin + scaledFrame + col * (pcbWidthUsed * scale + scaledSpace);
                    const y = margin + scaledFrame + row * (pcbHeightUsed * scale + scaledSpace);
                    const w = pcbWidthUsed * scale;
                    const h = pcbHeightUsed * scale;
                    
                    pcbs.push(
                        <g key={`pcb-group-${row}-${col}`}>
                            {/* Ombre du PCB */}
                            <rect
                                x={x + 2}
                                y={y + 2}
                                width={w}
                                height={h}
                                fill="#000000"
                                opacity="0.1"
                                rx="4"
                            />
                            {/* PCB principal */}
                            <rect
                                key={`pcb-${row}-${col}`}
                                x={x}
                                y={y}
                                width={w}
                                height={h}
                                fill="url(#pcbGradient)"
                                stroke="#047857"
                                strokeWidth="2.5"
                                rx="4"
                            />
                            {/* Reflet subtil */}
                            <rect
                                x={x + 4}
                                y={y + 4}
                                width={w - 8}
                                height={(h - 8) * 0.3}
                                fill="white"
                                opacity="0.15"
                                rx="2"
                            />
                        </g>
                    );
                    
                    pcbs.push(
                        <text
                            key={`label-${row}-${col}`}
                            x={x + w / 2}
                            y={y + h / 2}
                            textAnchor="middle"
                            dominantBaseline="middle"
                            fill="#ffffff"
                            fontSize="16"
                            fontWeight="600"
                            style={{ pointerEvents: 'none', textShadow: '0 1px 3px rgba(0,0,0,0.3)' }}
                        >
                            {row * cols + col + 1}
                        </text>
                    );
                }
            }
            
            const Dimension = ({ x1, y1, x2, y2, label, offset = 30, side = 'bottom' }) => {
                const isHorizontal = Math.abs(y2 - y1) < 1;
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                
                if (isHorizontal) {
                    const lineY = side === 'top' ? y1 - offset : y1 + offset;
                    return (
                        <g key={`dim-${x1}-${y1}-${x2}-${y2}`}>
                            <line x1={x1} y1={lineY} x2={x2} y2={lineY} stroke="#374151" strokeWidth="2" />
                            <polygon points={`${x1},${lineY} ${x1+8},${lineY-4} ${x1+8},${lineY+4}`} fill="#374151" />
                            <polygon points={`${x2},${lineY} ${x2-8},${lineY-4} ${x2-8},${lineY+4}`} fill="#374151" />
                            <line x1={x1} y1={y1} x2={x1} y2={lineY} stroke="#9ca3af" strokeWidth="1" strokeDasharray="4,4" />
                            <line x1={x2} y1={y2} x2={x2} y2={lineY} stroke="#9ca3af" strokeWidth="1" strokeDasharray="4,4" />
                            <rect 
                                x={midX - 30} 
                                y={lineY + (side === 'top' ? -24 : 6)} 
                                width="60" 
                                height="18" 
                                fill="white" 
                                stroke="#374151" 
                                strokeWidth="1"
                                rx="3"
                            />
                            <text 
                                x={midX} 
                                y={lineY + (side === 'top' ? -11 : 19)} 
                                textAnchor="middle" 
                                fill="#374151" 
                                fontSize="11" 
                                fontWeight="600"
                                fontFamily="monospace"
                            >
                                {label}
                            </text>
                        </g>
                    );
                } else {
                    const lineX = side === 'left' ? x1 - offset : x1 + offset;
                    return (
                        <g key={`dim-${x1}-${y1}-${x2}-${y2}`}>
                            <line x1={lineX} y1={y1} x2={lineX} y2={y2} stroke="#374151" strokeWidth="2" />
                            <polygon points={`${lineX},${y1} ${lineX-4},${y1+8} ${lineX+4},${y1+8}`} fill="#374151" />
                            <polygon points={`${lineX},${y2} ${lineX-4},${y2-8} ${lineX+4},${y2-8}`} fill="#374151" />
                            <line x1={x1} y1={y1} x2={lineX} y2={y1} stroke="#9ca3af" strokeWidth="1" strokeDasharray="4,4" />
                            <line x1={x2} y1={y2} x2={lineX} y2={y2} stroke="#9ca3af" strokeWidth="1" strokeDasharray="4,4" />
                            <rect 
                                x={lineX + (side === 'left' ? -35 : 5)} 
                                y={midY - 9} 
                                width="60" 
                                height="18" 
                                fill="white" 
                                stroke="#374151" 
                                strokeWidth="1"
                                rx="3"
                            />
                            <text 
                                x={lineX + (side === 'left' ? -5 : 35)} 
                                y={midY} 
                                textAnchor="middle" 
                                dominantBaseline="middle" 
                                fill="#374151" 
                                fontSize="11" 
                                fontWeight="600"
                                fontFamily="monospace"
                            >
                                {label}
                            </text>
                        </g>
                    );
                }
            };
            
            return (
                <div ref={containerRef} className="w-full bg-gradient-to-br from-gray-50 to-gray-100 p-6 rounded-xl shadow-2xl">
                    {/* En-tête professionnel */}
                    <div className="mb-6 pb-4 border-b-2 border-gray-300">
                        <div className="flex items-center justify-between">
                            <div>
                                <h2 className="text-2xl font-bold text-gray-800 tracking-tight">PLAN DE PANOPLIE</h2>
                                <p className="text-sm text-gray-500 font-medium mt-1">Cotations et spécifications techniques</p>
                            </div>
                            <div className="text-right">
                                <div className="text-xs text-gray-500 uppercase tracking-wider">Configuration</div>
                                <div className="text-lg font-bold text-gray-700">{cols}×{rows} PCB</div>
                                <div className="text-xs text-gray-600">{panoplieWidth.toFixed(1)}×{panoplieHeight.toFixed(1)}mm</div>
                            </div>
                        </div>
                    </div>
                    
                <svg ref={svgRef} width={svgWidth} height={svgHeight} className="mx-auto bg-white rounded-lg shadow-inner">
                    {/* Fond avec grille technique */}
                    <defs>
                        <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e5e7eb" strokeWidth="0.5"/>
                        </pattern>
                        <pattern id="gridMajor" width="100" height="100" patternUnits="userSpaceOnUse">
                            <rect width="100" height="100" fill="url(#grid)"/>
                            <path d="M 100 0 L 0 0 0 100" fill="none" stroke="#d1d5db" strokeWidth="1"/>
                        </pattern>
                        <filter id="shadow">
                            <feDropShadow dx="0" dy="2" stdDeviation="3" floodOpacity="0.15"/>
                        </filter>
                        <linearGradient id="pcbGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                            <stop offset="0%" style={{ stopColor: '#10b981', stopOpacity: 1 }} />
                            <stop offset="100%" style={{ stopColor: '#059669', stopOpacity: 1 }} />
                        </linearGradient>
                    </defs>
                    
                    {/* Fond avec grille */}
                    <rect width={svgWidth} height={svgHeight} fill="url(#gridMajor)"/>
                    
                    {/* Cadre externe principal */}
                    <rect
                        x={margin}
                        y={margin}
                        width={scaledW}
                        height={scaledH}
                        fill="none"
                        stroke="#1f2937"
                        strokeWidth="3"
                        rx="2"
                    />
                    
                    {/* Zone bande technique (cadre) */}
                    <rect
                        x={margin + scaledFrame}
                        y={margin + scaledFrame}
                        width={scaledW - 2 * scaledFrame}
                        height={scaledH - 2 * scaledFrame}
                        fill="#f8fafc"
                        stroke="#94a3b8"
                        strokeWidth="1.5"
                        strokeDasharray="4,4"
                    />
                    
                    {pcbs}
                    
                    <Dimension 
                        x1={margin} 
                        y1={margin} 
                        x2={margin + scaledW} 
                        y2={margin}
                        label={`${panoplieWidth.toFixed(1)}mm`}
                        offset={40}
                        side="top"
                    />
                    
                    <Dimension 
                        x1={margin + scaledW} 
                        y1={margin} 
                        x2={margin + scaledW} 
                        y2={margin + scaledH}
                        label={`${panoplieHeight.toFixed(1)}mm`}
                        offset={40}
                        side="right"
                    />
                    
                    <Dimension 
                        x1={margin} 
                        y1={margin} 
                        x2={margin + scaledFrame} 
                        y2={margin}
                        label={`${frame}mm`}
                        offset={20}
                        side="top"
                    />
                    
                    <Dimension 
                        x1={margin + scaledFrame} 
                        y1={margin + scaledFrame} 
                        x2={margin + scaledFrame + pcbWidthUsed * scale} 
                        y2={margin + scaledFrame}
                        label={`${pcbWidthUsed.toFixed(1)}mm`}
                        offset={20}
                        side="top"
                    />
                    
                    {cols > 1 && (
                        <Dimension 
                            x1={margin + scaledFrame + pcbWidthUsed * scale} 
                            y1={margin + scaledFrame + pcbHeightUsed * scale / 2} 
                            x2={margin + scaledFrame + pcbWidthUsed * scale + scaledSpace} 
                            y2={margin + scaledFrame + pcbHeightUsed * scale / 2}
                            label={`${space}mm`}
                            offset={15}
                            side="bottom"
                        />
                    )}
                    
                    <Dimension 
                        x1={margin + scaledFrame} 
                        y1={margin + scaledFrame} 
                        x2={margin + scaledFrame} 
                        y2={margin + scaledFrame + pcbHeightUsed * scale}
                        label={`${pcbHeightUsed.toFixed(1)}mm`}
                        offset={20}
                        side="left"
                    />
                    
                    {rows > 1 && (
                        <Dimension 
                            x1={margin + scaledFrame + pcbWidthUsed * scale / 2} 
                            y1={margin + scaledFrame + pcbHeightUsed * scale} 
                            x2={margin + scaledFrame + pcbWidthUsed * scale / 2} 
                            y2={margin + scaledFrame + pcbHeightUsed * scale + scaledSpace}
                            label={`${space}mm`}
                            offset={30}
                            side="left"
                        />
                    )}
                    
                    <Dimension 
                        x1={margin} 
                        y1={margin} 
                        x2={margin} 
                        y2={margin + scaledFrame}
                        label={`${frame}mm`}
                        offset={20}
                        side="left"
                    />
                    
                    {/* MIRES CMS - aux coins : x=BT/2, y=12.5mm */}
                    {/* Bas gauche */}
                    <CMSTarget 
                        x={margin + (frame / 2) * scale} 
                        y={margin + scaledH - 12.5 * scale} 
                        scale={scale} 
                        symbol="①"
                        isRight={false}
                    />
                    {/* Bas droite */}
                    <CMSTarget 
                        x={margin + scaledW - (frame / 2) * scale} 
                        y={margin + scaledH - 12.5 * scale} 
                        scale={scale} 
                        symbol="②"
                        isRight={true}
                    />
                    {/* Haut gauche */}
                    <CMSTarget 
                        x={margin + (frame / 2) * scale} 
                        y={margin + 12.5 * scale} 
                        scale={scale} 
                        symbol="③"
                        isRight={false}
                    />
                    
                    {/* TROUS DE LOCALISATION Ø3.05mm - aux coins : x=BT/2, y=5mm */}
                    {/* Bas gauche */}
                    <LocatingHole 
                        x={margin + (frame / 2) * scale} 
                        y={margin + scaledH - 5 * scale} 
                        scale={scale} 
                        symbol="A"
                        isRight={false}
                    />
                    {/* Bas droite */}
                    <LocatingHole 
                        x={margin + scaledW - (frame / 2) * scale} 
                        y={margin + scaledH - 5 * scale} 
                        scale={scale} 
                        symbol="B"
                        isRight={true}
                    />
                    {/* Haut gauche */}
                    <LocatingHole 
                        x={margin + (frame / 2) * scale} 
                        y={margin + 5 * scale} 
                        scale={scale} 
                        symbol="C"
                        isRight={false}
                    />
                    
                    {/* TRAITS DE V-CUT si entraxe = 0mm */}
                    {space === 0 && (
                        <>
                            {/* V-CUT verticaux (entre les colonnes) */}
                            {Array.from({ length: cols - 1 }, (_, i) => {
                                const x = margin + scaledFrame + (i + 1) * pcbWidthUsed * scale;
                                return (
                                    <VCutLine
                                        key={`vcut-v-${i}`}
                                        x1={x}
                                        y1={margin + scaledFrame}
                                        x2={x}
                                        y2={margin + scaledFrame + rows * pcbHeightUsed * scale}
                                        isHorizontal={false}
                                    />
                                );
                            })}
                            
                            {/* V-CUT horizontaux (entre les rangées) */}
                            {Array.from({ length: rows - 1 }, (_, i) => {
                                const y = margin + scaledFrame + (i + 1) * pcbHeightUsed * scale;
                                return (
                                    <VCutLine
                                        key={`vcut-h-${i}`}
                                        x1={margin + scaledFrame}
                                        y1={y}
                                        x2={margin + scaledFrame + cols * pcbWidthUsed * scale}
                                        y2={y}
                                        isHorizontal={true}
                                    />
                                );
                            })}
                        </>
                    )}
                </svg>
                
                {/* Tableau de légende professionnel */}
                <div className="mt-8 max-w-4xl mx-auto">
                    <div className="bg-white rounded-lg shadow-lg overflow-hidden border border-gray-200">
                        {/* En-tête du tableau */}
                        <div className="bg-gradient-to-r from-gray-800 to-gray-700 px-6 py-3">
                            <h3 className="text-white font-bold text-sm uppercase tracking-wider flex items-center gap-2">
                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                </svg>
                                Légende et spécifications
                            </h3>
                        </div>
                        
                        <div className="p-6 grid grid-cols-1 md:grid-cols-2 gap-6">
                            {/* MIRES CMS */}
                            <div className="border-l-4 border-red-500 pl-4">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 uppercase tracking-wide flex items-center gap-2">
                                    <span className="flex items-center justify-center w-6 h-6 bg-red-100 rounded-full text-red-600 text-xs">🎯</span>
                                    Mires CMS
                                </h4>
                                <table className="w-full text-xs border-collapse">
                                    <thead>
                                        <tr className="bg-gray-50">
                                            <th className="text-left py-2 px-3 font-semibold text-gray-600 border-b border-gray-200">Repère</th>
                                            <th className="text-left py-2 px-3 font-semibold text-gray-600 border-b border-gray-200">Position (mm)</th>
                                        </tr>
                                    </thead>
                                    <tbody className="text-gray-700">
                                        <tr className="border-b border-gray-100 hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-red-600">①</td>
                                            <td className="py-2 px-3 font-mono">x={(frame/2).toFixed(1)}, y=12.5 (Bas gauche)</td>
                                        </tr>
                                        <tr className="border-b border-gray-100 hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-red-600">②</td>
                                            <td className="py-2 px-3 font-mono">x=-{(frame/2).toFixed(1)}, y=12.5 (Bas droite)</td>
                                        </tr>
                                        <tr className="hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-red-600">③</td>
                                            <td className="py-2 px-3 font-mono">x={(frame/2).toFixed(1)}, y=-12.5 (Haut gauche)</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            {/* TROUS DE LOCATING */}
                            <div className="border-l-4 border-blue-500 pl-4">
                                <h4 className="text-sm font-bold text-gray-700 mb-3 uppercase tracking-wide flex items-center gap-2">
                                    <span className="flex items-center justify-center w-6 h-6 bg-blue-100 rounded-full text-blue-600 text-xs">⊙</span>
                                    Trous de locating
                                </h4>
                                <table className="w-full text-xs border-collapse">
                                    <thead>
                                        <tr className="bg-gray-50">
                                            <th className="text-left py-2 px-3 font-semibold text-gray-600 border-b border-gray-200">Repère</th>
                                            <th className="text-left py-2 px-3 font-semibold text-gray-600 border-b border-gray-200">Ø / Position (mm)</th>
                                        </tr>
                                    </thead>
                                    <tbody className="text-gray-700">
                                        <tr className="border-b border-gray-100 hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-blue-600">A</td>
                                            <td className="py-2 px-3 font-mono">3.05 - x={(frame/2).toFixed(1)}, y=5 (Bas gauche)</td>
                                        </tr>
                                        <tr className="border-b border-gray-100 hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-blue-600">B</td>
                                            <td className="py-2 px-3 font-mono">3.05 - x=-{(frame/2).toFixed(1)}, y=5 (Bas droite)</td>
                                        </tr>
                                        <tr className="hover:bg-gray-50 transition-colors">
                                            <td className="py-2 px-3 font-mono font-semibold text-blue-600">C</td>
                                            <td className="py-2 px-3 font-mono">3.05 - x={(frame/2).toFixed(1)}, y=-5 (Haut gauche)</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        {/* Annotation rainurage */}
                        {space === 0 && (
                            <div className="bg-amber-50 border-t border-amber-200 px-6 py-3">
                                <div className="flex items-center gap-3 text-sm text-amber-800">
                                    <span className="flex items-center justify-center w-8 h-8 bg-amber-200 rounded-full text-amber-900 font-bold">✂</span>
                                    <span className="font-medium">Rainurage V-CUT entre tous les PCB</span>
                                    <span className="text-xs italic opacity-75">(lignes orange en pointillés)</span>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            </div>
            );
        };

        const PanelVisualization = ({ config, panelFormat, frameMargin, spacing, onClick, scale: customScale, showLabels = false }) => {
            if (!config) return null;

            const parsedMargin = parseFloat(frameMargin);
                const margin = isNaN(parsedMargin) ? DEFAULT_VALUES.frameMargin : parsedMargin;
            const parsedSpace = parseFloat(spacing);
                const space = isNaN(parsedSpace) ? DEFAULT_VALUES.spacing : parsedSpace;

            const scale = customScale || Math.min(420 / panelFormat.width, 320 / panelFormat.height);
            const scaledPanelW = panelFormat.width * scale;
            const scaledPanelH = panelFormat.height * scale;
            const scaledMargin = margin * scale;

            const pcbs = [];
            const labels = [];

            if (config.isPanoplie) {
                const colors = [
                    { fill: 'fill-emerald-500', stroke: 'stroke-emerald-700' },
                    { fill: 'fill-blue-500', stroke: 'stroke-blue-700' },
                    { fill: 'fill-purple-500', stroke: 'stroke-purple-700' },
                    { fill: 'fill-pink-500', stroke: 'stroke-pink-700' },
                    { fill: 'fill-amber-500', stroke: 'stroke-amber-700' },
                    { fill: 'fill-cyan-500', stroke: 'stroke-cyan-700' },
                ];

                if (config.panoplieFramesData) {
                    config.panoplieFramesData.forEach((frame, index) => {
                        const x = scaledMargin + frame.x * scale;
                        const y = scaledMargin + frame.y * scale;
                        const w = frame.w * scale;
                        const h = frame.h * scale;
                        
                        pcbs.push(
                            <rect
                                key={`frame-${index}`}
                                x={x}
                                y={y}
                                width={w}
                                height={h}
                                className="fill-none stroke-gray-400 stroke-2 stroke-dashed"
                                rx="4"
                            />
                        );

                        if (showLabels) {
                            labels.push(
                                <text
                                    key={`label-${index}`}
                                    x={x + w / 2}
                                    y={y + h / 2}
                                    textAnchor="middle"
                                    dominantBaseline="middle"
                                    className="fill-white text-lg font-bold drop-shadow-lg"
                                    style={{ 
                                        pointerEvents: 'none',
                                        textShadow: '2px 2px 4px rgba(0,0,0,0.8), -1px -1px 2px rgba(0,0,0,0.8), 1px -1px 2px rgba(0,0,0,0.8), -1px 1px 2px rgba(0,0,0,0.8)'
                                    }}
                                >
                                    P{index + 1}
                                </text>
                            );
                        }
                    });
                }

                config.allPcbs.forEach((pcb, idx) => {
                    const x = scaledMargin + pcb.x * scale;
                    const y = scaledMargin + pcb.y * scale;
                    const w = pcb.w * scale;
                    const h = pcb.h * scale;
                    const colorSet = colors[pcb.panoplieIndex % colors.length];
                    
                    pcbs.push(
                        <rect
                            key={`pcb-${idx}`}
                            x={x}
                            y={y}
                            width={w}
                            height={h}
                            className={`${colorSet.fill} ${colorSet.stroke} stroke-1 transition-all duration-300 hover:opacity-80`}
                            rx="2"
                        />
                    );
                });
            } else {
                for (let row = 0; row < config.primaryRows; row++) {
                    for (let col = 0; col < config.primaryCols; col++) {
                        const x = scaledMargin + col * (config.primaryW + space) * scale;
                        const y = scaledMargin + row * (config.primaryH + space) * scale;
                        const w = config.primaryW * scale;
                        const h = config.primaryH * scale;
                        pcbs.push(
                            <rect
                                key={`primary-${row}-${col}`}
                                x={x}
                                y={y}
                                width={w}
                                height={h}
                                className="fill-emerald-500 stroke-emerald-700 stroke-1 transition-all duration-300 hover:fill-emerald-400"
                                rx="2"
                            />
                        );
                    }
                }

                config.secondaryPcbs.forEach((pcb, idx) => {
                    const x = scaledMargin + pcb.x * scale;
                    const y = scaledMargin + pcb.y * scale;
                    const w = pcb.w * scale;
                    const h = pcb.h * scale;
                    pcbs.push(
                        <rect
                            key={`secondary-${idx}`}
                            x={x}
                            y={y}
                            width={w}
                            height={h}
                            className="fill-purple-500 stroke-purple-700 stroke-1 transition-all duration-300 hover:fill-purple-400"
                            rx="2"
                        />
                    );
                });
            }

            return (
                <svg
                    width={scaledPanelW}
                    height={scaledPanelH}
                    className="mx-auto border-2 border-gray-200 rounded-lg shadow-inner bg-gradient-to-br from-gray-50 to-gray-100 cursor-pointer hover:border-blue-400 transition-all"
                    onClick={onClick}
                >
                    <rect
                        x="0"
                        y="0"
                        width={scaledPanelW}
                        height={scaledPanelH}
                        className="fill-amber-100/40 stroke-amber-400 stroke-2"
                        rx="4"
                    />
                    <rect
                        x={scaledMargin}
                        y={scaledMargin}
                        width={scaledPanelW - 2 * scaledMargin}
                        height={scaledPanelH - 2 * scaledMargin}
                        className="fill-none stroke-amber-500 stroke-1 stroke-dashed"
                    />
                    {pcbs}
                    {labels}
                </svg>
            );
        };

        const PCBPanelCalculator = () => {
            const [panelFormat, setPanelFormat] = useState(STANDARD_FORMATS[0]);
            const [pcbWidth, setPcbWidth] = useState('80');
            const [pcbHeight, setPcbHeight] = useState('70');
            const [frameMargin, setFrameMargin] = useState('15');
            const [spacing, setSpacing] = useState('5');
            const [customSpacing, setCustomSpacing] = useState('');
            const [showCustomSpacing, setShowCustomSpacing] = useState(false);
            const [enableMixedMode, setEnableMixedMode] = useState(true);
            const [showCustomPanel, setShowCustomPanel] = useState(false);
            const [customWidth, setCustomWidth] = useState('');
            const [customHeight, setCustomHeight] = useState('');
            const [showModal, setShowModal] = useState(false);
            const [showPanoplieModal, setShowPanoplieModal] = useState(false);
            
            const [panoplieMode, setPanoplieMode] = useState(false);
            const [panoplieCols, setPanoplieCols] = useState('2');
            const [panoplieRows, setPanoplieRows] = useState('3');
            const [panoplieOrientation, setPanoplieOrientation] = useState(0);
            const [panoplieFrameMargin, setPanoplieFrameMargin] = useState('8');
            const [panoplieEntraxe, setPanoplieEntraxe] = useState('5');

            const [showLabels, setShowLabels] = useState(false);
            const panoplieSvgRef = React.useRef(null);
            const panoplieContainerRef = React.useRef(null);

            useEffect(() => {
                if (panoplieMode) {
                    setSpacing('2');
                } else {
                    setSpacing('5');
                }
            }, [panoplieMode]);

            const calculateResult = useMemo(() => {
                if (panoplieMode) {
                    const cols = parseInt(panoplieCols) || 1;
                    const rows = parseInt(panoplieRows) || 1;
                    const pcbW = parseFloat(pcbWidth) || DEFAULT_VALUES.pcbWidth;
                    const pcbH = parseFloat(pcbHeight) || DEFAULT_VALUES.pcbHeight;
                    const parsedMargin = parseFloat(frameMargin);
                    const margin = isNaN(parsedMargin) ? DEFAULT_VALUES.frameMargin : parsedMargin;
                    const parsedSpace = parseFloat(spacing);
                    const space = isNaN(parsedSpace) ? DEFAULT_VALUES.panoplieSpacing : parsedSpace;
                    const parsedPanoplieFrame = parseFloat(panoplieFrameMargin);
                    const panoplieFrame = isNaN(parsedPanoplieFrame) ? DEFAULT_VALUES.panoplieFrameMargin : parsedPanoplieFrame;
                    const parsedPanoplieSpace = parseFloat(panoplieEntraxe);
                    const panoplieSpace = isNaN(parsedPanoplieSpace) ? DEFAULT_VALUES.panoplieEntraxe : parsedPanoplieSpace;
                    
                    const availableWidth = panelFormat.width - (2 * margin);
                    const availableHeight = panelFormat.height - (2 * margin);

                    const config = calculatePanoplieOptimization(
                        cols, rows, panoplieOrientation,
                        pcbW, pcbH, space, panoplieFrame, panoplieSpace,
                        availableWidth, availableHeight, enableMixedMode
                    );

                    return {
                        best: config,
                        allConfigs: [config],
                        availableWidth,
                        availableHeight
                    };
                } else {
                    return calculateAllConfigurations(
                        panelFormat,
                        pcbWidth,
                        pcbHeight,
                        frameMargin,
                        spacing,
                        enableMixedMode
                    );
                }
            }, [panelFormat, pcbWidth, pcbHeight, frameMargin, spacing, enableMixedMode, panoplieMode, panoplieCols, panoplieRows, panoplieOrientation, panoplieFrameMargin, panoplieEntraxe]);

            const addCustomFormat = () => {
                const w = parseFloat(customWidth);
                const h = parseFloat(customHeight);
                if (w > 0 && h > 0) {
                    setPanelFormat({ name: `${w}x${h}mm`, width: w, height: h, category: 'PERSONNALISÉ' });
                    setShowCustomPanel(false);
                    setCustomWidth('');
                    setCustomHeight('');
                }
            };

            const setPresetSpacing = (value) => {
                setSpacing(value.toString());
                setShowCustomSpacing(false);
                setCustomSpacing('');
            };

            const applyCustomSpacing = () => {
                const value = parseFloat(customSpacing);
                if (value >= 0) {
                    setSpacing(value.toString());
                    setShowCustomSpacing(false);
                }
            };

            const exportAsImage = () => {
                alert('Export d\'image à venir ! 📸');
            };

            const exportPanopliePNG = async () => {
                if (!panoplieContainerRef.current) return;
                
                try {
                    const container = panoplieContainerRef.current;
                    
                    // Utiliser html2canvas pour capturer toute la div (SVG + tableau)
                    const canvas = await html2canvas(container, {
                        scale: 2, // Haute résolution
                        backgroundColor: '#ffffff',
                        logging: false,
                        useCORS: true
                    });
                    
                    // Convertir en PNG et télécharger
                    canvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = `panoplie_${panoplieCols}x${panoplieRows}_${pcbWidth}x${pcbHeight}mm.png`;
                        link.click();
                        URL.revokeObjectURL(url);
                    }, 'image/png', 1.0);
                } catch (error) {
                    console.error('Erreur lors de l\'export PNG:', error);
                    alert('Erreur lors de l\'export. Veuillez réessayer.');
                }
            };

            const doubleFaceFormats = STANDARD_FORMATS.filter(f => f.category === 'DOUBLE FACE');
            const multicouchesFormats = STANDARD_FORMATS.filter(f => f.category === 'MULTICOUCHES');

            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-100 via-gray-50 to-slate-100">
                    {/* Header professionnel */}
                    <div className="bg-gradient-to-r from-slate-800 via-slate-700 to-slate-800 shadow-xl border-b-4 border-blue-500">
                        <div className="max-w-7xl mx-auto px-6 py-4">
                            <div className="flex items-center justify-between">
                                <div className="flex items-center gap-4">
                                    <div className="flex items-center justify-center w-14 h-14 bg-gradient-to-br from-blue-500 to-blue-600 rounded-lg shadow-lg">
                                        <Icon name="Cpu" className="w-8 h-8 text-white" />
                                    </div>
                                    <div>
                                        <h1 className="text-2xl font-bold text-white tracking-tight">
                                            PANÉLISATION PCB
                                        </h1>
                                        <p className="text-sm text-blue-200 font-medium">William-DEW</p>
                                    </div>
                                </div>
                                <div className="flex items-center gap-3">
                                    <div className="text-right">
                                        <div className="text-xs text-blue-200 uppercase tracking-wider">Version</div>
                                        <div className="text-sm font-bold text-white">2.0</div>
                                    </div>
                                    <button
                                        onClick={exportAsImage}
                                        className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg shadow-lg transition-all duration-200 flex items-center gap-2 font-semibold"
                                    >
                                        <Icon name="Download" className="w-4 h-4" />
                                        Exporter
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div className="max-w-7xl mx-auto p-6">
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            <div className="space-y-6">
                                {/* Mode de Calcul */}
                                <div className="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden">
                                    <div className="bg-gradient-to-r from-slate-700 to-slate-600 px-5 py-3">
                                        <h2 className="text-sm font-bold text-white uppercase tracking-wider flex items-center gap-2">
                                            <Icon name="Settings" className="w-4 h-4" />
                                            Mode de Calcul
                                        </h2>
                                    </div>
                                    <div className="p-5">
                                    <div className="grid grid-cols-2 gap-3 mb-4">
                                        <button
                                            onClick={() => setPanoplieMode(false)}
                                            className={`px-6 py-4 rounded-lg font-semibold transition-all duration-200 shadow-md ${ 
                                                !panoplieMode
                                                    ? 'bg-gradient-to-br from-blue-600 to-blue-700 text-white shadow-lg scale-105 border-2 border-blue-500'
                                                    : 'bg-white text-gray-700 hover:bg-gray-50 border-2 border-gray-200 hover:border-gray-300'
                                            }`}
                                        >
                                            <div className="flex flex-col items-center gap-2">
                                                <Icon name="CircuitBoard" className="w-6 h-6" />
                                                <span className="text-sm">Unitaire</span>
                                            </div>
                                        </button>
                                        <button
                                            onClick={() => setPanoplieMode(true)}
                                            className={`px-6 py-4 rounded-lg font-semibold transition-all duration-200 shadow-md ${
                                                panoplieMode
                                                    ? 'bg-gradient-to-br from-blue-600 to-blue-700 text-white shadow-lg scale-105 border-2 border-blue-500'
                                                    : 'bg-white text-gray-700 hover:bg-gray-50 border-2 border-gray-200 hover:border-gray-300'
                                            }`}
                                        >
                                            <div className="flex flex-col items-center gap-2">
                                                <Icon name="Grid3x3" className="w-6 h-6" />
                                                <span className="text-sm">Panoplie</span>
                                            </div>
                                        </button>
                                    </div>
                                    
                                    {/* Mode Mixte */}
                                    <div className="mt-4 bg-slate-50 rounded-lg p-4 border border-slate-200">
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-3">
                                                <Icon name="RotateCw" className="w-5 h-5 text-blue-600" />
                                                <div>
                                                    <h3 className="text-sm font-semibold text-gray-800">Mode Mixte</h3>
                                                    <p className="text-xs text-gray-500">Orientation combinée</p>
                                                </div>
                                            </div>
                                            <button
                                                onClick={() => setEnableMixedMode(!enableMixedMode)}
                                                className={`relative w-16 h-8 rounded-full transition-all duration-200 shadow-inner ${
                                                    enableMixedMode ? 'bg-blue-600' : 'bg-gray-300'
                                                }`}
                                            >
                                                <span
                                                    className={`absolute top-1 left-1 w-6 h-6 bg-white rounded-full transition-transform duration-200 shadow-md ${
                                                        enableMixedMode ? 'transform translate-x-8' : ''
                                                    }`}
                                                />
                                            </button>
                                        </div>
                                    </div>
                                    </div>
                                </div>

                                {/* Format du Panneau */}
                                <div className="bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden">
                                    <div className="bg-gradient-to-r from-slate-700 to-slate-600 px-5 py-3">
                                        <h2 className="text-sm font-bold text-white uppercase tracking-wider flex items-center gap-2">
                                            <Icon name="Maximize2" className="w-4 h-4" />
                                            Format du Panneau
                                        </h2>
                                    </div>
                                    <div className="p-5">
                                    <div className="space-y-4">
                                        <div>
                                            <div className="text-xs font-bold text-slate-700 mb-2 uppercase tracking-wide border-l-4 border-blue-500 pl-2">Double Face</div>
                                            <div className="grid grid-cols-3 gap-2">
                                                {doubleFaceFormats.map((format) => (
                                                    <button
                                                        key={format.name}
                                                        onClick={() => setPanelFormat(format)}
                                                        className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                            panelFormat.name === format.name
                                                                ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-md scale-105'
                                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                        }`}
                                                    >
                                                        {format.width}×{format.height}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-xs font-semibold text-gray-600 mb-1">MULTICOUCHES</div>
                                            <div className="grid grid-cols-2 gap-2">
                                                {multicouchesFormats.map((format) => (
                                                    <button
                                                        key={format.name}
                                                        onClick={() => setPanelFormat(format)}
                                                        className={`px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                            panelFormat.name === format.name
                                                                ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-md scale-105'
                                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                        }`}
                                                    >
                                                        {format.width}×{format.height}
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                        <button
                                            onClick={() => setShowCustomPanel(!showCustomPanel)}
                                            className="w-full px-3 py-2 rounded-lg text-sm font-medium bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:from-purple-600 hover:to-pink-600 transition-all duration-200"
                                        >
                                            ✨ Format personnalisé
                                        </button>
                                        {showCustomPanel && (
                                            <div className="flex gap-2 slide-in">
                                                <input
                                                    type="number"
                                                    placeholder="Largeur"
                                                    value={customWidth}
                                                    onChange={(e) => setCustomWidth(e.target.value)}
                                                    className="flex-1 px-3 py-2 text-sm border-2 border-gray-200 rounded-lg focus:border-blue-500 focus:outline-none"
                                                />
                                                <input
                                                    type="number"
                                                    placeholder="Hauteur"
                                                    value={customHeight}
                                                    onChange={(e) => setCustomHeight(e.target.value)}
                                                    className="flex-1 px-3 py-2 text-sm border-2 border-gray-200 rounded-lg focus:border-blue-500 focus:outline-none"
                                                />
                                                <button
                                                    onClick={addCustomFormat}
                                                    className="px-4 py-2 bg-green-500 text-white text-sm rounded-lg hover:bg-green-600"
                                                >
                                                    ✓
                                                </button>
                                            </div>
                                        )}
                                        <div className="text-xs text-gray-600 bg-blue-50 p-2 rounded-lg border border-blue-200">
                                            <span className="font-semibold text-blue-700">{panelFormat.category}</span>
                                            {' - '}
                                            <span className="font-semibold text-blue-700">{panelFormat.width} × {panelFormat.height} mm</span>
                                        </div>
                                    </div>
                                    </div>
                                </div>

                                <div className="bg-white rounded-xl shadow-lg p-4 section-card">
                                    <div className="flex items-center gap-2 mb-3">
                                        <Icon name="Grid3x3" className="w-4 h-4 text-emerald-600" />
                                        <h2 className="text-base font-semibold text-gray-800">Dimensions PCB</h2>
                                    </div>
                                    <div className="grid grid-cols-2 gap-3">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">Largeur (mm)</label>
                                            <input
                                                type="number"
                                                min="1"
                                                step="0.1"
                                                value={pcbWidth}
                                                onChange={(e) => setPcbWidth(e.target.value)}
                                                className="w-full px-3 py-2 border-2 border-emerald-200 rounded-lg focus:border-emerald-500 focus:outline-none text-sm font-semibold text-emerald-700 transition-all"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">Hauteur (mm)</label>
                                            <input
                                                type="number"
                                                min="1"
                                                step="0.1"
                                                value={pcbHeight}
                                                onChange={(e) => setPcbHeight(e.target.value)}
                                                className="w-full px-3 py-2 border-2 border-emerald-200 rounded-lg focus:border-emerald-500 focus:outline-none text-sm font-semibold text-emerald-700 transition-all"
                                            />
                                        </div>
                                    </div>
                                </div>

                                {panoplieMode && (
                                    <div className="bg-gradient-to-br from-purple-50 to-pink-50 rounded-xl shadow-lg p-4 border-2 border-purple-200 section-card slide-in">
                                        <div className="flex items-center gap-2 mb-3">
                                            <Icon name="LayoutGrid" className="w-4 h-4 text-purple-600" />
                                            <h2 className="text-base font-semibold text-gray-800">Configuration Panoplie</h2>
                                        </div>
                                        <div className="space-y-3">
                                            <div className="grid grid-cols-2 gap-3">
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Colonnes</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        value={panoplieCols}
                                                        onChange={(e) => setPanoplieCols(e.target.value)}
                                                        className="w-full px-3 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none text-sm font-semibold text-purple-700"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Rangées</label>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        value={panoplieRows}
                                                        onChange={(e) => setPanoplieRows(e.target.value)}
                                                        className="w-full px-3 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none text-sm font-semibold text-purple-700"
                                                    />
                                                </div>
                                            </div>
                                            <div className="grid grid-cols-2 gap-3">
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">
                                                        Cadre panoplie (mm)
                                                    </label>
                                                    <input
                                                        type="number"
                                                        min="0"
                                                        step="0.5"
                                                        value={panoplieFrameMargin}
                                                        onChange={(e) => setPanoplieFrameMargin(e.target.value)}
                                                        className="w-full px-3 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none text-sm font-semibold text-purple-700"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">
                                                        Entraxe entre les panoplies (mm)
                                                    </label>
                                                    <input
                                                        type="number"
                                                        min="0"
                                                        step="0.5"
                                                        value={panoplieEntraxe}
                                                        onChange={(e) => setPanoplieEntraxe(e.target.value)}
                                                        className="w-full px-3 py-2 border-2 border-purple-200 rounded-lg focus:border-purple-500 focus:outline-none text-sm font-semibold text-purple-700"
                                                    />
                                                </div>
                                            </div>
                                            <div>
                                                <label className="block text-xs font-medium text-gray-700 mb-2">Orientation</label>
                                                <div className="grid grid-cols-2 gap-2">
                                                    <button
                                                        onClick={() => setPanoplieOrientation(0)}
                                                        className={`px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                            panoplieOrientation === 0
                                                                ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md'
                                                                : 'bg-white text-gray-700 hover:bg-gray-50 border-2 border-purple-200'
                                                        }`}
                                                    >
                                                        0°
                                                    </button>
                                                    <button
                                                        onClick={() => setPanoplieOrientation(90)}
                                                        className={`px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                            panoplieOrientation === 90
                                                                ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white shadow-md'
                                                                : 'bg-white text-gray-700 hover:bg-gray-50 border-2 border-purple-200'
                                                        }`}
                                                    >
                                                        90°
                                                    </button>
                                                </div>
                                            </div>
                                            <div className="bg-purple-100 p-2 rounded-lg text-xs text-purple-800 flex items-center justify-between">
                                                <strong>PCB par panoplie:</strong>
                                                <span className="text-lg font-bold">{parseInt(panoplieCols) * parseInt(panoplieRows)}</span>
                                            </div>
                                        </div>
                                    </div>
                                )}

                                <div className="bg-white rounded-xl shadow-lg p-4 section-card">
                                    <div className="flex items-center gap-2 mb-3">
                                        <Icon name="Move" className="w-4 h-4 text-amber-600" />
                                        <h2 className="text-base font-semibold text-gray-800">Marges & Entraxe</h2>
                                    </div>
                                    <div className="space-y-3">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">
                                                Cadre panneau de production (mm)
                                            </label>
                                            <input
                                                type="number"
                                                min="0"
                                                step="0.5"
                                                value={frameMargin}
                                                onChange={(e) => setFrameMargin(e.target.value)}
                                                className="w-full px-3 py-2 border-2 border-amber-200 rounded-lg focus:border-amber-500 focus:outline-none text-sm font-semibold text-amber-700 transition-all"
                                            />
                                        </div>
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-2">
                                                Entraxe entre les PCB (mm)
                                            </label>
                                            <div className="grid grid-cols-5 gap-2 mb-2">
                                                {PRESET_SPACINGS.map((preset) => (
                                                    <button
                                                        key={preset.value}
                                                        onClick={() => setPresetSpacing(preset.value)}
                                                        className={`px-2 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                            parseFloat(spacing) === preset.value && !showCustomSpacing
                                                                ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white shadow-md'
                                                                : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                        }`}
                                                    >
                                                        {preset.label}
                                                    </button>
                                                ))}
                                            </div>
                                            <button
                                                onClick={() => setShowCustomSpacing(!showCustomSpacing)}
                                                className={`w-full px-3 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                                                    showCustomSpacing
                                                        ? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                ✏️ Autre
                                            </button>
                                            {showCustomSpacing && (
                                                <div className="flex gap-2 mt-2 slide-in">
                                                    <input
                                                        type="number"
                                                        placeholder="Ex: 7.5"
                                                        min="0"
                                                        step="0.1"
                                                        value={customSpacing}
                                                        onChange={(e) => setCustomSpacing(e.target.value)}
                                                        className="flex-1 px-3 py-2 text-sm border-2 border-blue-200 rounded-lg focus:border-blue-500 focus:outline-none"
                                                    />
                                                    <button
                                                        onClick={applyCustomSpacing}
                                                        className="px-4 py-2 bg-green-500 text-white text-sm rounded-lg hover:bg-green-600"
                                                    >
                                                        ✓
                                                    </button>
                                                </div>
                                            )}
                                            {spacing && (
                                                <div className="mt-2 text-center text-xs font-semibold text-blue-700 bg-blue-50 p-2 rounded-lg">
                                                    ✓ Entraxe PCB actuel : {spacing}mm
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div className="space-y-3">
                                <div className={`rounded-xl shadow-xl p-4 text-white section-card ${
                                    panoplieMode 
                                        ? 'bg-gradient-to-br from-purple-500 to-pink-600' 
                                        : 'bg-gradient-to-br from-green-500 to-emerald-600'
                                }`}>
                                    <div className="flex items-center justify-between mb-3">
                                        <h2 className="text-xl font-bold">
                                            {panoplieMode ? '🎯 Panélisation Panoplie' : '⚡ Configuration Optimale'}
                                        </h2>
                                        <Icon name={panoplieMode ? "LayoutGrid" : "TrendingUp"} className="w-6 h-6" />
                                    </div>
                                    <div className="space-y-2">
                                        {panoplieMode && (
                                            <>
                                                <div className="flex justify-between items-center">
                                                    <span className="text-purple-100 text-sm">Panoplies principales:</span>
                                                    <span className="text-2xl font-bold">
                                                        {calculateResult.best.totalPanopliesPrimary}
                                                        <span className="text-sm ml-1">
                                                            ({calculateResult.best.panopliesPerRow}×{calculateResult.best.panopliesPerCol})
                                                        </span>
                                                    </span>
                                                </div>
                                                {enableMixedMode && calculateResult.best.secondaryPanoplies > 0 && (
                                                    <div className="flex justify-between items-center">
                                                        <span className="text-purple-100 text-sm">Panoplies pivotées:</span>
                                                        <span className="text-xl font-bold text-pink-200">
                                                            {calculateResult.best.secondaryPanoplies}
                                                        </span>
                                                    </div>
                                                )}
                                                <div className="flex justify-between items-center">
                                                    <span className="text-purple-100 text-sm">PCB par panoplie:</span>
                                                    <span className="text-xl font-bold">
                                                        {calculateResult.best.pcbsPerPanoplie}
                                                        <span className="text-sm ml-1">
                                                            ({panoplieCols}×{panoplieRows})
                                                        </span>
                                                    </span>
                                                </div>
                                                <div className="h-px bg-white/30 my-1"></div>
                                            </>
                                        )}
                                        {!panoplieMode && (
                                            <>
                                                <div className="flex justify-between items-center">
                                                    <span className="text-green-100 text-sm">Orientation principale:</span>
                                                    <span className="text-2xl font-bold">{calculateResult.best.primaryOrientation}°</span>
                                                </div>
                                                <div className="flex justify-between items-center">
                                                    <span className="text-green-100 text-sm">PCB principaux:</span>
                                                    <span className="text-xl font-bold">
                                                        {calculateResult.best.primaryCount} 
                                                        <span className="text-sm ml-1">({calculateResult.best.primaryCols}×{calculateResult.best.primaryRows})</span>
                                                    </span>
                                                </div>
                                                {enableMixedMode && calculateResult.best.secondaryCount > 0 && (
                                                    <div className="flex justify-between items-center">
                                                        <span className="text-green-100 text-sm">PCB pivotés:</span>
                                                        <span className="text-xl font-bold text-purple-200">
                                                            {calculateResult.best.secondaryCount}
                                                        </span>
                                                    </div>
                                                )}
                                                <div className="h-px bg-white/30 my-1"></div>
                                            </>
                                        )}
                                        <div className="flex justify-between items-center bg-white/10 rounded-lg p-2">
                                            <span className={panoplieMode ? 'text-purple-100 font-semibold' : 'text-green-100 font-semibold'}>
                                                🎯 Total PCB:
                                            </span>
                                            <span className="text-3xl font-bold">{calculateResult.best.totalCount}</span>
                                        </div>
                                        <div className="flex justify-between items-center">
                                            <span className={panoplieMode ? 'text-purple-100 text-sm' : 'text-green-100 text-sm'}>
                                                📊 Taux d'utilisation:
                                            </span>
                                            <span className="text-xl font-bold">
                                                {calculateResult.best.utilization.toFixed(1)}%
                                            </span>
                                        </div>
                                    </div>
                                </div>

                                <div className="bg-white rounded-xl shadow-lg p-4 section-card">
                                    <div className="flex items-center justify-between mb-3">
                                        <h3 className="text-sm font-semibold text-gray-800">
                                            👁️ Aperçu de la Configuration
                                        </h3>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => setShowLabels(!showLabels)}
                                                className={`p-1 rounded transition-all ${showLabels ? 'bg-blue-100 text-blue-600' : 'text-gray-400 hover:text-gray-600'}`}
                                            >
                                                <Icon name="Tag" className="w-4 h-4" />
                                            </button>
                                        </div>
                                    </div>
                                    <div className="flex justify-center mb-3">
                                        <PanelVisualization 
                                            config={calculateResult.best}
                                            panelFormat={panelFormat}
                                            frameMargin={frameMargin}
                                            spacing={spacing}
                                            onClick={() => setShowModal(true)}
                                            showLabels={showLabels}
                                        />
                                    </div>
                                    {panoplieMode && (
                                        <div className="mb-3 bg-purple-50 p-3 rounded-lg text-xs text-purple-800 border border-purple-200">
                                            <div className="flex items-center justify-between mb-2">
                                                <div className="font-semibold flex items-center gap-1">
                                                    <Icon name="Info" className="w-5 h-5" />
                                                    Détails panoplie:
                                                </div>
                                                <button
                                                    onClick={() => setShowPanoplieModal(true)}
                                                    className="px-3 py-1 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-all text-xs font-semibold flex items-center gap-1"
                                                >
                                                    <Icon name="Ruler" className="w-3 h-3" />
                                                    Flan avec cotations
                                                </button>
                                            </div>
                                            <div className="grid grid-cols-2 gap-2">
                                                <div>📦 Total panoplies: <strong>{calculateResult.best.totalPanoplies}</strong></div>
                                                {enableMixedMode && calculateResult.best.secondaryPanoplies > 0 && (
                                                    <div>🔄 Panoplies pivotées: <strong>{calculateResult.best.secondaryPanoplies}</strong></div>
                                                )}
                                                <div>📐 Taille principale: {calculateResult.best.panoplieWidth.toFixed(1)}×{calculateResult.best.panoplieHeight.toFixed(1)}mm</div>
                                                <div>🎨 Cadre: {(() => { const p = parseFloat(panoplieFrameMargin); return isNaN(p) ? 8 : p; })()}mm</div>
                                                <div>📏 Entraxe PCB: {(() => { const p = parseFloat(spacing); return isNaN(p) ? 2 : p; })()}mm</div>
                                                <div>↔️ Entraxe panoplies: {(() => { const p = parseFloat(panoplieEntraxe); return isNaN(p) ? 5 : p; })()}mm</div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                    </div>

                    {showModal && (
                        <div 
                            className="fixed inset-0 bg-black/60 modal-backdrop flex items-center justify-center z-50 p-4"
                            onClick={() => setShowModal(false)}
                        >
                            <div 
                                className="bg-white rounded-2xl p-6 max-w-6xl max-h-[90vh] overflow-auto relative slide-in"
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-2xl font-bold text-gray-800">🔍 Visualisation détaillée</h2>
                                    <button
                                        onClick={() => setShowModal(false)}
                                        className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
                                    >
                                        <Icon name="X" className="w-6 h-6" />
                                    </button>
                                </div>
                                <div className="flex justify-center">
                                    <PanelVisualization 
                                        config={calculateResult.best}
                                        panelFormat={panelFormat}
                                        frameMargin={frameMargin}
                                        spacing={spacing}
                                        scale={Math.min(1000 / panelFormat.width, 700 / panelFormat.height)}
                                        showLabels={showLabels}
                                    />
                                </div>
                                <div className="mt-4 text-center text-gray-600 text-sm">
                                    💡 Cliquez en dehors ou sur ✕ pour fermer
                                </div>
                            </div>
                        </div>
                    )}

                    {showPanoplieModal && (
                        <div 
                            className="fixed inset-0 bg-black/60 modal-backdrop flex items-center justify-center z-50 p-4"
                            onClick={() => setShowPanoplieModal(false)}
                        >
                            <div 
                                className="bg-white rounded-2xl p-6 max-w-7xl max-h-[95vh] overflow-auto relative slide-in"
                                onClick={(e) => e.stopPropagation()}
                            >
                                <div className="flex items-center justify-between mb-4">
                                    <div>
                                        <h2 className="text-2xl font-bold text-gray-800">📐 Panoplie avec cotations</h2>
                                        <p className="text-sm text-gray-600">Vue détaillée d'une panoplie individuelle</p>
                                    </div>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={exportPanopliePNG}
                                            className="px-4 py-2 bg-gradient-to-r from-green-500 to-emerald-600 text-white rounded-lg hover:from-green-600 hover:to-emerald-700 transition-all shadow-lg flex items-center gap-2 font-semibold"
                                        >
                                            <Icon name="Download" className="w-5 h-5" />
                                            PNG
                                        </button>
                                        <button
                                            onClick={() => setShowPanoplieModal(false)}
                                            className="p-2 hover:bg-gray-100 rounded-lg transition-colors"
                                        >
                                            <Icon name="X" className="w-6 h-6" />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex justify-center">
                                    <PanoplieVisualization
                                        panoplieCols={panoplieCols}
                                        panoplieRows={panoplieRows}
                                        pcbWidth={pcbWidth}
                                        pcbHeight={pcbHeight}
                                        spacing={spacing}
                                        panoplieFrameMargin={panoplieFrameMargin}
                                        orientation={panoplieOrientation}
                                        svgRef={panoplieSvgRef}
                                        containerRef={panoplieContainerRef}
                                    />
                                </div>
                                <div className="mt-4 text-center space-y-2">
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<PCBPanelCalculator />);
    </script>
</body>
</html>